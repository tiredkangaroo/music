// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTrackToPlaylist = `-- name: AddTrackToPlaylist :exec
INSERT INTO playlist_tracks (playlist_id, track_id)
VALUES ($1, $2)
`

type AddTrackToPlaylistParams struct {
	PlaylistID pgtype.UUID
	TrackID    string
}

func (q *Queries) AddTrackToPlaylist(ctx context.Context, arg AddTrackToPlaylistParams) error {
	_, err := q.db.Exec(ctx, addTrackToPlaylist, arg.PlaylistID, arg.TrackID)
	return err
}

const createPlaylist = `-- name: CreatePlaylist :one
INSERT INTO playlists (name, description, image_url)
VALUES ($1, $2, $3)
RETURNING id
`

type CreatePlaylistParams struct {
	Name        string
	Description string
	ImageUrl    string
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPlaylist, arg.Name, arg.Description, arg.ImageUrl)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists WHERE id = $1
`

func (q *Queries) DeletePlaylist(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePlaylist, id)
	return err
}

const getTrackByID = `-- name: GetTrackByID :one
SELECT track_id, track_name, duration, popularity, album_id, artist_id, artists, track_release_date FROM tracks WHERE track_id = $1
`

func (q *Queries) GetTrackByID(ctx context.Context, trackID string) (Track, error) {
	row := q.db.QueryRow(ctx, getTrackByID, trackID)
	var i Track
	err := row.Scan(
		&i.TrackID,
		&i.TrackName,
		&i.Duration,
		&i.Popularity,
		&i.AlbumID,
		&i.ArtistID,
		&i.Artists,
		&i.TrackReleaseDate,
	)
	return i, err
}

const insertTrack = `-- name: InsertTrack :exec
WITH upsert_artist AS (
    INSERT INTO artists (artist_id, artist_name)
    VALUES ($1, $2)
    ON CONFLICT (artist_id) DO NOTHING
),
upsert_album AS (
    INSERT INTO albums (album_id, album_name, artist_id, cover_url, album_release_date)
    VALUES ($3, $4, $1, $5, $6)
    ON CONFLICT (album_id) DO NOTHING
)
INSERT INTO tracks (
    track_id,
    track_name,
    duration,
    popularity,
    album_id,
    artist_id,
    artists,
    track_release_date
)
VALUES (
    $7,
    $8,
    $9,
    $10,
    $3,
    $1,
    $11,
    $12
)
ON CONFLICT (track_id) DO NOTHING
`

type InsertTrackParams struct {
	ArtistID         string
	ArtistName       string
	AlbumID          string
	AlbumName        string
	CoverUrl         string
	AlbumReleaseDate pgtype.Date
	TrackID          string
	TrackName        string
	Duration         int32
	Popularity       int32
	Artists          []string
	TrackReleaseDate pgtype.Date
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) error {
	_, err := q.db.Exec(ctx, insertTrack,
		arg.ArtistID,
		arg.ArtistName,
		arg.AlbumID,
		arg.AlbumName,
		arg.CoverUrl,
		arg.AlbumReleaseDate,
		arg.TrackID,
		arg.TrackName,
		arg.Duration,
		arg.Popularity,
		arg.Artists,
		arg.TrackReleaseDate,
	)
	return err
}

const listPlaylistTracks = `-- name: ListPlaylistTracks :many
SELECT t.track_id, t.track_name, t.duration, t.popularity, t.album_id, t.artist_id, t.artists, t.track_release_date
FROM tracks t
JOIN playlist_tracks pt ON t.track_id = pt.track_id
WHERE pt.playlist_id = $1
`

func (q *Queries) ListPlaylistTracks(ctx context.Context, playlistID pgtype.UUID) ([]Track, error) {
	rows, err := q.db.Query(ctx, listPlaylistTracks, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.TrackID,
			&i.TrackName,
			&i.Duration,
			&i.Popularity,
			&i.AlbumID,
			&i.ArtistID,
			&i.Artists,
			&i.TrackReleaseDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylists = `-- name: ListPlaylists :many
SELECT id, name, description, image_url, created_at FROM playlists ORDER BY created_at DESC
`

func (q *Queries) ListPlaylists(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, listPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordPlay = `-- name: RecordPlay :exec
INSERT INTO plays (track_id, played_at, skipped_at)
VALUES ($1, $2, $3)
ON CONFLICT (track_id, played_at) DO NOTHING
`

type RecordPlayParams struct {
	TrackID   string
	PlayedAt  pgtype.Timestamp
	SkippedAt pgtype.Int4
}

func (q *Queries) RecordPlay(ctx context.Context, arg RecordPlayParams) error {
	_, err := q.db.Exec(ctx, recordPlay, arg.TrackID, arg.PlayedAt, arg.SkippedAt)
	return err
}

const recordSkip = `-- name: RecordSkip :exec
UPDATE plays
SET skipped_at = $1
WHERE track_id = $2 AND played_at = $3
`

type RecordSkipParams struct {
	SkippedAt pgtype.Int4
	TrackID   string
	PlayedAt  pgtype.Timestamp
}

func (q *Queries) RecordSkip(ctx context.Context, arg RecordSkipParams) error {
	_, err := q.db.Exec(ctx, recordSkip, arg.SkippedAt, arg.TrackID, arg.PlayedAt)
	return err
}

const removeTrackFromPlaylist = `-- name: RemoveTrackFromPlaylist :exec
DELETE FROM playlist_tracks
WHERE playlist_id = $1 AND track_id = $2
`

type RemoveTrackFromPlaylistParams struct {
	PlaylistID pgtype.UUID
	TrackID    string
}

func (q *Queries) RemoveTrackFromPlaylist(ctx context.Context, arg RemoveTrackFromPlaylistParams) error {
	_, err := q.db.Exec(ctx, removeTrackFromPlaylist, arg.PlaylistID, arg.TrackID)
	return err
}

const searchTrackByName = `-- name: SearchTrackByName :many
SELECT track_id, track_name, duration, popularity, tracks.album_id, tracks.artist_id, artists, track_release_date, albums.album_id, album_name, albums.artist_id, cover_url, album_release_date, artists.artist_id, artist_name FROM tracks
JOIN albums ON tracks.album_id = albums.album_id
JOIN artists ON tracks.artist_id = artists.artist_id
WHERE track_name ILIKE '%' || $1 || '%'
LIMIT $2 OFFSET $3
`

type SearchTrackByNameParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

type SearchTrackByNameRow struct {
	TrackID          string
	TrackName        string
	Duration         int32
	Popularity       int32
	AlbumID          string
	ArtistID         string
	Artists          []string
	TrackReleaseDate pgtype.Date
	AlbumID_2        string
	AlbumName        string
	ArtistID_2       string
	CoverUrl         string
	AlbumReleaseDate pgtype.Date
	ArtistID_3       string
	ArtistName       string
}

func (q *Queries) SearchTrackByName(ctx context.Context, arg SearchTrackByNameParams) ([]SearchTrackByNameRow, error) {
	rows, err := q.db.Query(ctx, searchTrackByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchTrackByNameRow
	for rows.Next() {
		var i SearchTrackByNameRow
		if err := rows.Scan(
			&i.TrackID,
			&i.TrackName,
			&i.Duration,
			&i.Popularity,
			&i.AlbumID,
			&i.ArtistID,
			&i.Artists,
			&i.TrackReleaseDate,
			&i.AlbumID_2,
			&i.AlbumName,
			&i.ArtistID_2,
			&i.CoverUrl,
			&i.AlbumReleaseDate,
			&i.ArtistID_3,
			&i.ArtistName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
