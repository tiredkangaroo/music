// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTrackToPlaylist = `-- name: AddTrackToPlaylist :exec
INSERT INTO playlist_tracks (playlist_id, track_id)
VALUES ($1, $2)
`

type AddTrackToPlaylistParams struct {
	PlaylistID pgtype.UUID `json:"playlist_id"`
	TrackID    string      `json:"track_id"`
}

func (q *Queries) AddTrackToPlaylist(ctx context.Context, arg AddTrackToPlaylistParams) error {
	_, err := q.db.Exec(ctx, addTrackToPlaylist, arg.PlaylistID, arg.TrackID)
	return err
}

const createPlaylist = `-- name: CreatePlaylist :one
INSERT INTO playlists (name, description, image_url)
VALUES ($1, $2, $3)
RETURNING id
`

type CreatePlaylistParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ImageUrl    string `json:"image_url"`
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPlaylist, arg.Name, arg.Description, arg.ImageUrl)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists WHERE id = $1
`

func (q *Queries) DeletePlaylist(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePlaylist, id)
	return err
}

const getPlaylist = `-- name: GetPlaylist :one
SELECT
    p.id,
    p.name,
    p.description,
    p.image_url,
    p.created_at,
    COALESCE(
        json_agg(
            json_build_object(
                'track_id', t.track_id,
                'track_name', t.track_name,
                'duration', t.duration,
                'popularity', t.popularity,
                'album_id', t.album_id,
                'artist_id', t.artist_id,
                'artists', t.artists,
                'track_release_date', t.track_release_date
            )
        ) FILTER (WHERE t.track_id IS NOT NULL),
        '[]'::json
    ) AS tracks
FROM playlists p
LEFT JOIN playlist_tracks pt ON pt.playlist_id = p.id
LEFT JOIN tracks t ON t.track_id = pt.track_id
WHERE p.id = $1
GROUP BY p.id
`

type GetPlaylistRow struct {
	ID          pgtype.UUID      `json:"id"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	ImageUrl    string           `json:"image_url"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	Tracks      interface{}      `json:"tracks"`
}

func (q *Queries) GetPlaylist(ctx context.Context, id pgtype.UUID) (GetPlaylistRow, error) {
	row := q.db.QueryRow(ctx, getPlaylist, id)
	var i GetPlaylistRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.Tracks,
	)
	return i, err
}

const getTrackByID = `-- name: GetTrackByID :one
SELECT track_id, track_name, duration, popularity, album_id, artist_id, artists, track_release_date FROM tracks WHERE track_id = $1
`

func (q *Queries) GetTrackByID(ctx context.Context, trackID string) (Track, error) {
	row := q.db.QueryRow(ctx, getTrackByID, trackID)
	var i Track
	err := row.Scan(
		&i.TrackID,
		&i.TrackName,
		&i.Duration,
		&i.Popularity,
		&i.AlbumID,
		&i.ArtistID,
		&i.Artists,
		&i.TrackReleaseDate,
	)
	return i, err
}

const insertTrack = `-- name: InsertTrack :exec
WITH upsert_artist AS (
    INSERT INTO artists (artist_id, artist_name)
    VALUES ($1, $2)
    ON CONFLICT (artist_id) DO NOTHING
),
upsert_album AS (
    INSERT INTO albums (album_id, album_name, artist_id, cover_url, album_release_date)
    VALUES ($3, $4, $1, $5, $6)
    ON CONFLICT (album_id) DO NOTHING
)
INSERT INTO tracks (
    track_id,
    track_name,
    duration,
    popularity,
    album_id,
    artist_id,
    artists,
    track_release_date
)
VALUES (
    $7,
    $8,
    $9,
    $10,
    $3,
    $1,
    $11,
    $12
)
ON CONFLICT (track_id) DO NOTHING
`

type InsertTrackParams struct {
	ArtistID         string      `json:"artist_id"`
	ArtistName       string      `json:"artist_name"`
	AlbumID          string      `json:"album_id"`
	AlbumName        string      `json:"album_name"`
	CoverUrl         string      `json:"cover_url"`
	AlbumReleaseDate pgtype.Date `json:"album_release_date"`
	TrackID          string      `json:"track_id"`
	TrackName        string      `json:"track_name"`
	Duration         int32       `json:"duration"`
	Popularity       int32       `json:"popularity"`
	Artists          []string    `json:"artists"`
	TrackReleaseDate pgtype.Date `json:"track_release_date"`
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) error {
	_, err := q.db.Exec(ctx, insertTrack,
		arg.ArtistID,
		arg.ArtistName,
		arg.AlbumID,
		arg.AlbumName,
		arg.CoverUrl,
		arg.AlbumReleaseDate,
		arg.TrackID,
		arg.TrackName,
		arg.Duration,
		arg.Popularity,
		arg.Artists,
		arg.TrackReleaseDate,
	)
	return err
}

const listPlaylists = `-- name: ListPlaylists :many
SELECT id, name, description, image_url, created_at FROM playlists ORDER BY created_at DESC
`

func (q *Queries) ListPlaylists(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, listPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordPlay = `-- name: RecordPlay :exec
INSERT INTO plays (track_id, played_at, skipped_at)
VALUES ($1, $2, $3)
ON CONFLICT (track_id, played_at) DO NOTHING
`

type RecordPlayParams struct {
	TrackID   string           `json:"track_id"`
	PlayedAt  pgtype.Timestamp `json:"played_at"`
	SkippedAt pgtype.Int4      `json:"skipped_at"`
}

func (q *Queries) RecordPlay(ctx context.Context, arg RecordPlayParams) error {
	_, err := q.db.Exec(ctx, recordPlay, arg.TrackID, arg.PlayedAt, arg.SkippedAt)
	return err
}

const recordSkip = `-- name: RecordSkip :exec
UPDATE plays
SET skipped_at = $1
WHERE track_id = $2 AND played_at = $3
`

type RecordSkipParams struct {
	SkippedAt pgtype.Int4      `json:"skipped_at"`
	TrackID   string           `json:"track_id"`
	PlayedAt  pgtype.Timestamp `json:"played_at"`
}

func (q *Queries) RecordSkip(ctx context.Context, arg RecordSkipParams) error {
	_, err := q.db.Exec(ctx, recordSkip, arg.SkippedAt, arg.TrackID, arg.PlayedAt)
	return err
}

const removeTrackFromPlaylist = `-- name: RemoveTrackFromPlaylist :exec
DELETE FROM playlist_tracks
WHERE playlist_id = $1 AND track_id = $2
`

type RemoveTrackFromPlaylistParams struct {
	PlaylistID pgtype.UUID `json:"playlist_id"`
	TrackID    string      `json:"track_id"`
}

func (q *Queries) RemoveTrackFromPlaylist(ctx context.Context, arg RemoveTrackFromPlaylistParams) error {
	_, err := q.db.Exec(ctx, removeTrackFromPlaylist, arg.PlaylistID, arg.TrackID)
	return err
}

const searchTrackByName = `-- name: SearchTrackByName :many
SELECT track_id, track_name, duration, popularity, tracks.album_id, tracks.artist_id, artists, track_release_date, albums.album_id, album_name, albums.artist_id, cover_url, album_release_date, artists.artist_id, artist_name FROM tracks
JOIN albums ON tracks.album_id = albums.album_id
JOIN artists ON tracks.artist_id = artists.artist_id
WHERE track_name ILIKE '%' || $1 || '%'
LIMIT $2 OFFSET $3
`

type SearchTrackByNameParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchTrackByNameRow struct {
	TrackID          string      `json:"track_id"`
	TrackName        string      `json:"track_name"`
	Duration         int32       `json:"duration"`
	Popularity       int32       `json:"popularity"`
	AlbumID          string      `json:"album_id"`
	ArtistID         string      `json:"artist_id"`
	Artists          []string    `json:"artists"`
	TrackReleaseDate pgtype.Date `json:"track_release_date"`
	AlbumID_2        string      `json:"album_id_2"`
	AlbumName        string      `json:"album_name"`
	ArtistID_2       string      `json:"artist_id_2"`
	CoverUrl         string      `json:"cover_url"`
	AlbumReleaseDate pgtype.Date `json:"album_release_date"`
	ArtistID_3       string      `json:"artist_id_3"`
	ArtistName       string      `json:"artist_name"`
}

func (q *Queries) SearchTrackByName(ctx context.Context, arg SearchTrackByNameParams) ([]SearchTrackByNameRow, error) {
	rows, err := q.db.Query(ctx, searchTrackByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchTrackByNameRow
	for rows.Next() {
		var i SearchTrackByNameRow
		if err := rows.Scan(
			&i.TrackID,
			&i.TrackName,
			&i.Duration,
			&i.Popularity,
			&i.AlbumID,
			&i.ArtistID,
			&i.Artists,
			&i.TrackReleaseDate,
			&i.AlbumID_2,
			&i.AlbumName,
			&i.ArtistID_2,
			&i.CoverUrl,
			&i.AlbumReleaseDate,
			&i.ArtistID_3,
			&i.ArtistName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
